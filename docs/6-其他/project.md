# 大屏设计器

## 权限管理

### 页面路由权限

权限管理，在页面权限方面采用路由标记，在配置路由的时候给路由对象增加一个标记，用来表示那些角色可以访问该路由，用数组表示，比如

```js
{
    path: '/home',
    name: 'home',
    component: Home,
    meta: {
        roles: ['admin', 'editor']
    }
}
```

在路由切换的时候，根据当前用户的角色，判断该用户是否有权限访问该路由，如果没有权限，则跳转到403页面。

对于管理页面的菜单数据，采用 `vuex` 封装一个`getters` 属性，根据当前用户的角色以及路由数组，生成当前角色的菜单数据。

### 按钮权限

按钮权限，在页面中，根据当前用户的角色，判断该用户是否有权限访问该按钮，如果没有权限，则隐藏该按钮。技术上采用的是自定义指令和状态管理保存的当前用户角色相结合，判断按钮是否应该展示

```js
<el-button v-permission="['admin']">编辑</el-button>
```

### 需求变化

需求变化了，单单通过角色来判断权限是不够的，因为当权限具体到一些模块的可见、增删查改操作的控制的时候就不好控制了，比如角色`admin` 和 `user` 都可以控制某个列表的可见，但是 `admin` 有增删改的所有权限，而 `user`只有查看的权限，这时候怎么控制增删改的权限就不好控制了。

所以，后来修改了权限控制系统，在角色的基础上，增加了模块，以及模块的操作（如增删改）。模块可以指某个页面，通常为列表，操作通常为增删改。这样就可以给每个角色分配不同的模块和不同的操作了。数据可以表现为：

```json
{
  // admin 角色
  "admin": {
    // 模块 userTable
    "userTable": ["*"], // 拥有模块所有的操作
    // 模块 table2
    "table2": ["*"]
  },
  // user 角色
  "user": {
    // 模块 userTable
    "userTable": ["query"], // 只拥有查看操作
    // 模块 table2
    "table2": ["query"] // 只拥有查看操作
  }
}
```

技术上使用的是 `acl` 库，通过 `acl.can` 方法来判断当前用户是否有权限访问该模块的操作。关键代码如下：

定义角色和模块
```js
app.acl.allow([
  {
    roles: ['admin'],
    allows: [
      { resources: 'userTable', permissions: ['*'] },
      { resources: 'table2', permissions: ['*'] },
    ],
  },
  {
    roles: ['user'],
    allows: [
      { resources: 'userTable', permissions: ['query'] },
      { resources: 'table2', permissions: ['query'] },
    ],
  },
]);
```

判断当前用户是否有权限访问该模块的操作
```js
let roleList = ['admin', 'guest']
;(async () => {
  let permissions = await acl.whatResources(roleList)
  console.log('permissions', permissions)
})()

```

## 大屏获取数据优化 `EventSource`


## 集成 `swagger-egg` 自动生成接口文档
## 自动截图（canvas 和 electron 系统截图）


# 金智维宣传平台

## 双 `token` 刷新

这个项目有一个`cms` 的后台系统，用来管理网站文章和文件等资源的，需要登录才能进入系统。期初的登录方式是使用单`token`，有效时间是1个小时。之后有些用户发现有时候在使用中用着用着就提示 token 无效被强制退出登录，体验不好。因此就做了双`token`刷新。

- 用户登录成功后，后台生成一个`token`，有效期是1个小时，和一个刷新 token `refreshToken`，刷新token的有效期比token长。
- 在登录状态下，所有的请求头都加上token请求数据
- 一旦请求头中的token过期，前端会自动请求刷新token的接口，获取新的token和刷新token，然后将新的token和刷新token存到本地缓存中，下次请求时带上新的token。
- 其中token 和刷新 token 都使用 localstorage 进行本地存储。请求是token会被添加都请求头中，刷新 token 不会添加到请求头中。

该案例也在大屏页面轮询获取时使用了，避免了token过期后，页面轮询获取数据失败的问题。

## 大文件上传
宣传平台有很多视频素材需要上传，因为上传比较耗时，所以做了分片上传优化。技术实现是这样的：首先，在逻辑上将大文件内容分割成多个分片，并不是物理上分割成多个独立文件；然后，这些分片会被上传到服务器；最后，服务器会将所有分片按照序号合并还原成原始的大文件。每个分片都会标记对应的分片序号，以便后端进行拼接。同时，为了提高上传效率和避免重复上传，每个分片都会计算出一个哈希值用于校验。由于哈希值的计算是CPU密集型的操作，因此前端使用了多线程（通过Web Worker实现）来异步计算这些哈希值，以充分利用CPU资源。线程的数量被设置为与CPU的核心数相匹配，以确保最高效的计算过程。一旦哈希值计算完成，它们会通过Web Worker发送回主线程。这样做显著提高了哈希值的计算效率。随后，主线程将这些带有哈希值和分片序号的分片分批发送给后端服务器，通过批量并发上传来最大限度地提高请求的并发效率和带宽利用率。以上使用多线程分片和并发上传的策略，确实可以显著提升文件上传的整体效率。

并对断点续传进行优化。断点续传是一种在文件上传过程中，当网络中断或其他原因导致上传被打断时，能够从中断点继续上传文件的技术。为了实现这一功能，前端和后端都需要记录已经上传的分片信息（包括哈希值、分片序号等）。在网络恢复后，前端会检查并继续上传未完成的分片，而后端会验证并接收这些分片，最终将所有分片合并成一个完整的文件。

## 多语言
期初项目还没有多语言的需求，所以没有进行多语言的配置。因此很多页面都是对中文进行了定制化的。这不仅带来的实现方案的确定以及重构成本。当然后来技术上使用的是`i18n` 库，利用它实现了多语言的模板。由于当时这个 `i18n` 对我而言也是个新东西，所以我花了不少时间去调研。

当然，使用了`i18n` 之后，需要定制语言模板，然后重构页面代码，把文字模板都替换成`i18n` 模板表达式就行了，再配合`vuex`状态管理绑定 `i18n` 当前语言环境。

在体验上也做了一些优化，比如利用 `localstroage` 做了语言本地持久化，记录用户习惯的语言，避免下次使用时还需要手动切换。

不是为了说这个东西很难，只是想说有些东西开头很难，只要肯花些时间去琢磨，最后你都会发现其实也就那样。

## 服务端渲染方案
## SEO 优化
## 百度地图
## 手机和邮箱验证
这个项目有一个后台管理系统，用来管理文章内容和资源文件的，登录需要手机和邮箱验证。手机验证码使用的`聚合数据`提供的`api`。也不是说为了说这个点很难，只是当时我需要兼顾前后端的开发，所以如何实现手机验证码，以及如何在前端实现手机验证码的输入，都是我需要考虑的问题。因为当时对我来说也是全新的东西。需要学习`api`的使用，以及如何在前端实现手机验证码的输入。所以在调研方面加了好几天班研究，这不仅仅是后端还有前端。

**聚合数据短信 `api` 的使用大概如下**
1. 注册账号（公司已有），申请短信验证码API，并获取 `请求key`
2. 创建短信模板，并获取模板 ID
3. 调用`api`发送短信

**使用手机验证码登录的过程**
1. 首先用于输入手机号，并发送验证码。为了避免用户频繁点击发送验证码操作导致白白消耗掉 `api` 的次数，前、后端都做了80秒后重发的限制。
2. 输入验证码，并登录，手机号和验证码一起发送到后端，后端验证手机号和验证码是否匹配。
3. 登录成功后，后端返回一个 `token`，前端将 `token` 存储到本地，后续的请求，都会携带这个 `token`。

其中后端80秒重试的做法是，调用`api` 的到验证码后，把手机号和对应验证码存到哈希表中，并设置一个80秒的过期时间。


## 腾讯云对象存储 `sdk`
## 集成 swagger 自动生成接口文档



# 企微自建应用

## 打印页面表单以及优化

这个应用有些页面表单需要打印，但是但是只是打印页面的局部内容。一开始采用的方法是把 `dom` 转 `dataUri`，然后在把图片打印。但是后来发现这个方法并不好，因为打印的图片质量不太好，存在效率问题，并且会存在要是丢失的问题。然后进行了第一次优化，把需要打印的部分内容嵌入到 `iframe` 中，然后通过 `iframe` 内部的`window.print` 对象打印整个 `iframe` 内容。虽然这个方法解决了样式问题，并且直接调用 `window.print` 比之前转 `dataUri` 效率更高，但是还是存在丢失问题。但是开发有点麻烦。并且有点不优雅。

然后又进行了第二次优化，去掉了`iframe` 通过使用媒体查询 `@media print` 设置打印样式，把不需要打印的页面内容隐藏掉，然后通过 `window.print` 打印整个页面。这样打印的时候就会只选取需要打印的内容，并且不会丢失样式。而且效率也好。

## 请求幂等
## 请求缓存，http 缓存，跟后台说明 http 缓存的要求

针对页面加载过慢的问题，特别是由于数据接口响应时间过长，我们进行了深入排查。领导要求前后端团队共同协作，我提出了使用`HTTP`协商缓存作为解决方案。

具体实现上，后端在接口响应头中添加`Last-Modified`或`ETag`标记，用于标识资源状态。前端在请求时，携带这些标记作为参数。后端收到请求后，会校验资源是否自上次请求以来被修改。如果未修改，则返回304状态码，告诉前端使用缓存数据。

这种方法能够减少不必要的网络请求和数据传输，显著提高页面加载速度。它需要前后端团队的紧密合作，确保缓存策略的正确实施。在实际应用中，我们还应根据业务场景灵活调整缓存策略，以达到最佳优化效果。

## 阿里图标管理方案
## 内网穿透实现高效开发